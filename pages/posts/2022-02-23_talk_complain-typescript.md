---
title: 吐槽 TypeScript
date: 2022-02-23
duration: 8分钟
subtitle: 文章首发于 2020/08/18，这里只是迁移
tag: 旧
type: talk
---

说起 TypeScript，认识的还蛮早，因为不喜欢强类型，所以并不是很喜欢。但是随着越来越多的程序员使用，慢慢的我也重新审视自己，是不是太井底之蛙了。

所以我最近又重新拾起，一边阅读一些优秀的 TypeScript 源码，一边编写小工具 [resize-detector](https://www.npmjs.com/package/resize-detector-typescript)，为了巩固下所学。终于结束了，对比之前我使用 js 直接开发功能，在使用 ts 时候，谈下我使用后的一些想法：

首先是环境搭建，说实话真的要看个人，你是喜欢简单版还是进阶版还是完整版，因为我是基于一个开源的第三方库编写，自然需要完整。然后我就*到处*找各种配置，终于配制出适合自己的。不过因为是初版，到现在依旧不是很满意，但勉强可以使用了。

那么环境搭建完毕，就要开始写代码了，写代码途中我发现，之前声明了如下的类型：

```ts
export type XXX = string | undefined | null
```

因为我需要使用这种类型，结果无意间看到一个 type，叫做 `PropertyKey`，和我这种类型一模一样，这就很尴尬了，等于我重复定义了一个变量。而这个 `PropertyKey` 它是个全局变量，这是内置的。有人可能会说你不会去参考看下 lib.dom 库啊，可是关键如果一个新手来做，他知道这个库吗？

这是写类型遇到的第一个问题：**内置类型/接口不知道如何寻找**。

当然第一个问题对于我来说还是很好解决的，那么第二个问题就有些复杂，就是我写了一个公共的回调函数，在 ts 中因为不同的接口实现都定义了一套自己的回调类型，结果就是我写的这个方法不停的在转化类型（目前也是这么做的，应该可以优化）。于是我就想到能不能根据谁使用，那么根据使用者来推断类型。答案自然是有的，毕竟我是个后来者，在网络上的列子中我知道了 `extends` 和 `infer` 关键字，说真的，至少当时我激动了，有解决方案。可以网络上说的真的太基础，或者官网示例，虽然看了很多，但是说清楚的没几个，至于到现在我对这个 `infer` 只有特定环境才可以明白如何写，接口就是我依旧没有找到方法去实现我的想法（有一篇[文章](https://my.oschina.net/u/4318809/blog/4293100) 我个人觉着讲的还行，因为不是盲目的粘贴复制）。这是我遇到的第二个问题：**如何编写高校的检测类型**。

遇到的第三个就是关于`eslint`，我使用的是`ts`团队自家产品 `@typescript-eslint/eslint-plugin`，可以说提示的还不错，但是每次在写到`js`中的`object`类型我就是很纠结，因为推荐我使用`Record`类型，我也听话了，用上后发现一个很尴尬的，我自己定义的`option`对象不能被`Record`类型兼容，我定义的`options`类型就是`<string, unknow>`，`Record`类型也是`Record<string, unknow>`为什么不行呢，后来我换成了`object`类型就可以，就目前而言，关于对象的表示我依旧不是很清楚怎么写，是写`Object`，还是`object`，还是`Record`，虽然`eslint`推荐使用`Record`，我是真的迷糊了。这只是我举得一个列子，其实就是想说我遇到的第三个问题：**到底应该如何使用合理的类型**。

~~那么第四个问题，我需要向原始对象`HTMLElement`添加属性，但是`ts`提示不可以，我也能理解，所以我为了不污染这个`HTMLElement`，我重新声明了一个新的接口（假设是`IDomNode`）继承`HTMLElement`，然后我就基于我声明的新的接口`IDomNode`写，写到最后都是没有问题的，发布完我测试，发现当然调用方法传入`HTMLElement`，提示不行，因为`HTMLElement`没有`IDomNode`上的一些属性，关键我这个`IDomNode`又不是一上来就有，难道我需要自己再写个方法将每一个`HTMLElement`初始化成`IDomNode`，最后我先使用了折中办法，将所有的`IDomNode`类的属性变成可选，这就导致只要是使用到`IDomNode`的属性就必须先判空，虽然我可以肯定他们存在，但是`ts`不信他们是存在的。所以我又写了一堆方法判空，感觉显得很多余。~~ \[今天突然开窍了，我应该在内部自行将`HTMLElement`转成 `IDomNode`转化才可以，果真还是使用的姿势不对。\]

差不多了，其实网上很多评论对比，当然都不及自己去写写，使用中出现很多问题，即便到现在发布了，我也不敢说这是稳定版，只能发布了一个alpha版本。TypeScript 正如字面可以很好的检测类型，但是多数需要自己合理编写一些检测类型来推断。

说真的我觉得还是蛮搞笑，以前直接写`es5`，后来`es6`出来了，写`es6`，但是为了照顾老浏览器，最后将`es6`转成`es5`在编写，现在是写`typescript`，再转成es6，感觉有毒啊😄。

感觉是不是我使用`typescript`的姿势不对，就目前而言，更多感觉像是枷锁，也许后面使用多了可能会好一些。那时候就会出现**真相警告**了吧。
